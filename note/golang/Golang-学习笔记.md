# Golang 学习笔记 :goat:

## 1 基础和数据类型

Go 不需要在语句或声明后面使用`;`，除非有多个语句或者声明在同一行。跟在特定符号后面的换行符被转换为`;`，在什么地方换行，会影响到 Go 代码的解析。

**一些常识**

1. 实体以大写字母开头，则对包外可见。

2. 通常倾向于短的名称，名称的作用域越大，就使用越长且更有意义的名称。

3. Go 里面不存在未初始化的变量，因为零值机制保障了所有变量都是良好定义的。

```go
var s string
fmt.Println(s)  // ""
```

4. 表达式 `new(T)`创建了一个未命名的 T 类型变量。类似于 Java 中的匿名对象。

**数据类型**

- 基础类型
- 聚合类型
- 引用类型
- 接口类型

Go 语言在调用一个函数的时候，每个传入的参数都会创建一个**副本**，然后赋值给对应的函数变量，所以函数接收的是一个副本，而不是原始的参数。使用这种方式传递大的数组时会比较低效，并且函数内部对数组的任何修改都仅影响副本，而不是原数组。而在其它语言中，数组时隐式地使用引用传递。

如果想避免这种情况，那就传递一个数组的**指针**。

```go
a := [...]int{1, 2, 3, 4}	// 数组
b := []int{1, 2, 3, 4}		// 切片
c := arr[startIndex:endIndex]  // 将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片

numbers := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}
number3 := numbers[3:5]  // number3 的容量为 6，丢弃了索引为3之前的容量
```

### 1.1 数组

```go
var intArr [3]int  // 定义完数组后，数组已经赋初值 [0 0 0]
```

跟 c 语言一样，数组的地址就是数组第一个元素的地址。

**数组遍历**

```go
for index, value := range intArr {
    
}
```

### 1.2 切片

创建方式

```go
// 1
var arr = [...]int{1, 2, 3}
var slice = arr[1:3]  // 这个arr对外可见，因为事先存在   [1, 3)
// 2
slice ：= make([]int, len, cap)
```

**切片引用的数组对外不可见**，只能通过 slice 进行访问。

### 1.3 结构体

```go
type A struct {
    Name string
    Age int
    slice []int		// 默认初始值为 nil，使用时需要先 a.slice = make([]int, 100)
}
```

默认为值传递。

## 2 数据

### new 分配

new 是一个用来分配内存的内建函数，但是它不会初始化内存，只会将其置零。

例如：`new(T)`会为类型 T 分配已经置零的内存，并返回它的地址`*T`

### make 分配

内建函数 `make(T, `*args*`)` 的目的不同于 `new(T)`。它只用于创建切片、映射和信道，并返回类型为 `T`（而非 `*T`）的一个**已初始化** （而非**置零**）的值。 出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量， 在这三项被初始化之前，该切片为 `nil`。对于切片、映射和信道，`make` 用于初始化其内部的数据结构并准备好将要使用的值。例如，

```go
make([]int, 10, 100)
```

下面的例子阐明了 `new` 和 `make` 之间的区别：

```go
var p *[]int = new([]int)       // 分配切片结构；*p == nil；基本没用
var v  []int = make([]int, 100) // 切片 v 现在引用了一个具有 100 个 int 元素的新数组

// 没必要的复杂：
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 习惯用法：
v := make([]int, 100)
```

`make` 只适用于映射、切片和信道且不返回指针。若要获得明确的指针， 请使用 `new` 分配内存。

## 3 闭包

例子：

```go
func Add() func (int) int {
    var n int = 10					// 闭包
    return func (x int) int {		// 闭包
        n += x						// 闭包
        return n					// 闭包
    }								// 闭包
}
func main {
    f := Add()
    fmt.Println(f(1))  // 11
    fmt.Println(f(1))  // 12
    fmt.Println(f(1))  // 13
}
```

**理解：**

闭包是类，函数是操作，n 是字段，函数和它是用到 n 构成闭包。

好处：可以把匿名函数引用到的变量保存下来，以供后续使用，可以省去使用全局变量。