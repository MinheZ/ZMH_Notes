* [红黑树](#红黑树)
    * [1 平衡树和非平衡树](#平衡树和非平衡树)
    * [2 旋转](#旋转)
* [2-3-4树和外部储存](#2-3-4树和外部储存)
    * [插入](#插入)
    * [2-3-4树转变为红黑树](#2-3-4树转变为红黑树)


-----------------------

# 红黑树
红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet.解决非平衡树问题的方法。主要讨论插入操作。

**自顶向下插入：**

在搜索例程沿着树向下查找插入点，在此进程中可能要对树的结构做一些改变。

## 平衡树和非平衡树
创建一颗只有一个节点的树，然后插入一系列升序或者降序的关键字。如下图
<div align="center"><img src="../pics//1547174373(1).png" width="400px"></div>
这些节点排在一条直线上，没有分支，所有的节点都在根的一侧，这棵树属于极端不平衡的情况。

### 时间复杂度降低到O(N)
当树没有分支的时候，就相当于一个链表。对于随机数据的实际数量来说，一颗特别不平衡的情况不太可能，因此部分非平衡树的时间介于O(N)和Olog(N)之间，这取决于树的不平衡程度。

### 红黑树的特征
- 节点都有颜色。
- 在插入和删除的过程中，要遵循保持这些颜色的不同排列规则。

**红-黑规则**

插入（删除）一个新节点都要遵循的规则：
- 每一个节点不是红色的就是黑色的；
- 根节点总是黑色的；
- 如果节点是红色的，则他的子节点必须是黑色的；
- 从根到叶节点(没有子节点)或空子节点的每条路径，都必须包含相同数目的黑色节点。

在从根到叶节点路径上黑色节点的数目称为 **黑色高度(black height)**。

### 修正违规的情况
假设看到颜色的规则被违犯了，有且只有下列2种的修正措施：
- 改变节点的颜色；
- 执行旋转操作

## 旋转
旋转必须做2件事：
- 使一些节点上升，一些节点下降，帮助树平衡；
- 保证不破坏二叉搜索树的特征；

选择则一个节点作为旋转的“顶端”。如果做一次右旋，这个顶端节点将会移动到它右子节点的位置，左子节点将会移动到它原来的位置（必须确保右旋必须有一个左子节点）。左旋类似。**旋转不会改变每颗子树中节点的相互关系**。

**推荐文章：**
- [漫画：什么是红黑树](https://juejin.im/post/5a27c6946fb9a04509096248#comment)
- [红黑树深入剖析及Java实现](https://zhuanlan.zhihu.com/p/24367771)

-------------------------
# 2-3-4树和外部储存
## 2-3-4树的介绍
2-3-4树，就是多叉树。它的每个节点最多有4个子节点和3个数据项。
<div align="center"><img src="../pics//1547517555(1).jpg" width="800px"></div>
2-3-4树中所有的叶节点总是在同一层上。非叶节点的子节点数总是比它含有的数据项多1。

**用符号可表示为：** L=D+1

2-3-4树的节点如下：
<div align="center"><img src="../pics//1547518687(1).jpg" width="500px"></div>

### 2-3-4树的组织
用0~2的数字给数据项编号，0~3的数字给子节点链编号 。2-3-4树的关键字存储顺序跟二叉树一样，但是新增了如下图的规则：
<div align="center"><img src="../pics//1547519007(1).jpg" width="500px"></div>

## 插入
查找时没有碰到**满节点**时，插入很简单。找到合适的叶节点后，只要把心数据项插入进去就可以了：
<div align="center"><img src="../pics//1547520090(1).jpg" width="600px"></div>

### 节点分裂
如果在寻找要插入位置的路途中，节点已经满了。这种情况下必须分裂(split)。把要分裂的节点中数据项设为A、B、C。下面是分裂时的情况（**假设分裂的节点不是根**）:
- 创建一个新的空节点。它是要分裂节点的兄弟，要放在分裂节点的右边。
- 数据项C移到新节点中。
- 数据项B移到要分裂节点的父节点中。
- 数据项A保留在原来的位置上。
- 最右边的两个子节点从分裂节点处断开，连接到新的节点上。
<div align="center"><img src="../pics//1547520399(1).png" width="700px"></div>
插入只需要分裂一个节点，除非插入路径上存在不止一个满的节点。这种情况需要多重分裂。

### 根的分裂
如果一开始查找插入点就碰到满的根时：
- 创建新的根。它是要分裂节点的父节点。
- 创建第二个新节点。它是要分裂节点的兄弟节点。
- 数据项C移动到新的兄弟节点中。
- 数据项B移动到新的根节点中。
- 数据项A保留在原来的位置上。
- 要分裂的节点最右边两个子节点断开连接，连接到新的兄弟节点上。
<div align="center"><img src="../pics//1547520780(1).png" width="700px"></div>

### 在下行路途中分裂
所有满的节点都是在下行路中分裂的。下面显示的是空树中的一系列插入过程。有4个节点分裂了，2个是根，2个是叶节点。
<div align="center"><img src="../pics//1547521301(1).png" width="700px"></div>

## 2-3-4树转变为红黑树
应用三条规则可以吧2-3-4树转变为红黑树：
- 把2-3-4树中的每个2-节点转化为红黑树的黑色节点；
- 把每个3-节点转化为一个子节点和一个父节点。子节点有2个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色；
- 把每个4-节点转化成一个度节点和两个子节点。第一个子节点有它自己的子节点W和X，第二个子节点拥有子节点Y和Z。子节点涂成红色，父节点涂成黑色。
<div align="center"><img src="../pics//1547542271.png" width="700px"></div>
2-3-4树转化为红黑树实例：
<div align="center"><img src="../pics//1547542349(1).png" width="700px"></div>
可以想象为抓着中间的数据项，把整棵树“拎”起来。
