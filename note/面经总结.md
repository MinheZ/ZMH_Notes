* [Java虚拟机](#Java虚拟机)
* [Java并发](#Java并发)
    <!-- * [讲讲volatile](#讲讲volatile) -->
* [计算机网络](#计算机网络)
* [框架](#框架)
    * [SpringMVC](#SpringMVC)

----------------------------

# Java虚拟机

------------------------------

# Java并发
**[讲讲volatile](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#volatile%E5%8F%98%E9%87%8F)**

**指令重排序:**
```java
package reordering;

public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread{
        public void run(){
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args){
        // coding here
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```
上述代码中，NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。或者读线程看到ready的值，却没有看到number的值，输出为0.这种现状称为“重排序”。

**怎么用32位jvm对64位的数据进行原子操作？**

使用volatile关键字修饰，或者加锁。

**Java并发计数:**

AtomicInteger。

**[CAS算法](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2compare-and-swap-cas)**、**[ABA问题](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#aba%E9%97%AE%E9%A2%98)**

**[如果存储线程的阻塞队列满了，那么线程池的submit方法会阻塞在那里吗？](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5)**

看具体饱和策略如何设置的。

------------------------------
# 计算机网络

**[TCP三次握手，四次挥手](https://github.com/MinheZ/Notes/blob/master/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md#tcp%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)**

----------------------------

# 框架
## Servlet
### Servlet的生命周期
客户端第一次访问该Servlet的时候才会创建一个Servlet的对象，那么Servlet中的init方法就会执行。任何一次从客户端发送的请，那么服务器创建一个新的线程执行Servlet中service方法为这次请求服务。
service方法的内部根据请求的方式的不同调用不同doXXX的方法。当Servlet从服务器中移除或者关闭服务器的时候Servlet对象就会被销毁.destroy的方法就会执行。

### Servlet 3.0 新特性
- 异步处理支持：有了该特性，Servlet 线程不再需要一直阻塞，直到业务处理完毕才能再输出响应，最后才结束该 Servlet 线程。在接收到请求之后，Servlet 线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度。
- 新增的注解支持：该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。
- 可插性支持：开发者可以通过插件的方式很方便的扩充已有 Web 应用的功能，而不需要修改原有的应用。

## SpringMVC
**作用：** 从请求中接收传入的参数，将处理后的结果数据返回给页面。
### SpringMVC处理请求的流程
SpringMVC提供了前端控制器(Dispatcher Servlet)；处理器映射器(Handler Mapping)和处理适配器（Handler Adapter），视图解析器(View Resolver)进行视图管理；动作处理器Controller接口（包含ModelAndView，以及处理请求响应对象request和response），配置灵活，支持文件上传，数据简单转化等强大功能。
<div align="center"><img src="../pics//1550804996(1).png" width="650px"></div>

工作流程如下：
- 客户通过url发送请求
- 前端控制器(Dispatcher Servlet)接收到请求，通过系统或自定义的处理器映射器找到对应的Handler，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。
- DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作
- 执行处理器Handler(Controller，也叫页面控制器)。
- Handler执行完成返回ModelAndView
- HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet
- DispatcherServlet将ModelAndView传给ViewReslover视图解析器
- ViewReslover解析后返回具体View
- DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。
- DispatcherServlet响应用户。

### 适配器的作用
SpringMVC涉及的映射器，视图解析器的作用不难理解，映射器负责将前端请求的url映射到配置的处理器，视图解析器将最终的结果进行解析，但中间为什么要经过一层处理器适配器呢，为什么不经映射器找到controller后直接执行返回呢？

那是因为SpringMVC为业务处理器提供了多种接口实现（例如实现了Controller接口），而适配器就是用来根据处理器实现了什么接口，最终选择与已经注册好的不同类型的Handler Adapter进行匹配，并最终执行，例如，SimpleControllerHandlerAdapter是支持实现了controller接口的控制器，如果自己写的控制器实现了controller接口，那么SimpleControllerHandlerAdapter就会去执行自己写的控制器中的具体方法来完成请求。
