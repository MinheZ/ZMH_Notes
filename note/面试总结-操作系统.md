<!-- IO, 文件管理等。Linux 软连接，
硬链接区别。用户态和内核态。
socket，session等
Java 的锁在操作系统中以什么方式实现 -->

* [1 Java 的锁在操作系统中以什么方式实现](#1-Java-的锁在操作系统中以什么方式实现)
* [2 软链接和硬链接的区别](#2-软链接和硬链接的区别)
* [3 用户态和内核态的区别](#3-用户态和内核态的区别)

-----------------------------

## 1 Java 的锁在操作系统中以什么方式实现

我们知道jvm是属于运行在操作系统上的程序虚拟机。要想真正理解jvm是如何实现锁机制的,底层操作系统的锁机制是必须要了解的。 
我们知道在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区资源的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区，从而保证临界区中操作数据的一致性。

锁可以理解为内存中的一个变量标识，拥有两种状态：unlock,locked.任何想要访问获得锁的线程必须执行以下指令流：

```java
load lock #将lock内存值加载进cpu 
read lock state 
if lock.state=="unlock" 
set lock.state to "locked" #将lock状态设置会内存 
return true 
return false 
```

- 中断机制

  将指令流变成原子操作。在执行执行这些指令时,可以通过开关中断来保证锁机制指令流的原子性。中断是系统级别的指令,最好不允许用户操作,如果代码中没有正确的开关中断,容易引发系统死机。

- [CAS](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2compare-and-swap-cas) 机制

- 内存锁机制

  以上是在单核 cpu 下执行没有问题。但是在多核 cpu 下开关中断是针对当前cpu，所以也没法保证原子性。我们主要到以上锁机制是需要读写内存操作的。

  如果我们将只运行一个线程同时操作内存，问题就好解决。我们就想到 cpu 与内存进行通信的总线。即锁住总线即可。


## 2 软链接和硬链接的区别

[5分钟让你明白“软链接”和“硬链接”的区别](https://www.jianshu.com/p/dde6a01c4094)。

## 3 用户态和内核态的区别

[Linux探秘之用户态与内核态](https://www.cnblogs.com/bakari/p/5520860.html)。

