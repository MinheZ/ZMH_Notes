* [并行和并发有什么区别](#并行和并发有什么区别)
* [线程和进程的区别](#线程和进程的区别)
* [守护线程](#守护线程)
* [创建线程有哪几种方式](#创建线程有哪几种方式)

---------------

## 并行和并发有什么区别
- 并发是指有处理多个任务的能力
- 并行是指有**同时**处理多个任务的能力

## 线程和进程的区别
计算机中**进程就是包括上下文切换的程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文**。

假设一个进程 `A` 比喻为运行在电脑上的软件，那么这个软件可能有 `a`, `b`, `c`三个块组成，那么当进程 `A`得到 `CPU` 时，再加载完上下文之后，开始执行`a, b, c`三个小块，最后保存上下文。

这里`a, b, c`就是线程，它们共享了进程 `A` 的上下文。简而言之，**线程共享了进程的上下文环境，占用更细小的CPU时间段**。

## 守护线程
线程分为2种：普通线程和守护线程。在 JVM 启动时创建的所有线程中，除了主线程以外，其它的全是守护线程(例如垃圾回收器以及执行辅助工作的线程)。**当创建一个新的线程时，新线程将继承创建它的线程的守护状态**，因此在默认情况下，主线程创建的所有线程都是普通线程。

**尽可能少使用守护线程！**。 当一个线程退出时，JVM 会检查其它正在运行的线程，如果这些线程都是守护线程，则 JVM 会正常退出操作。 当 JVM 停止时，所有仍然存在的线程都将被抛弃——既不会执行 finally 块，也不会执行回卷栈。

守护线程最好用于执行“内部”任务，例如周期性得从内存的缓存中移除过期的数据。










**[讲讲volatile](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#volatile%E5%8F%98%E9%87%8F)**

### 指令重排序
```java
package reordering;

public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread{
        public void run(){
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }
    public static void main(String[] args){
        // coding here
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```
上述代码中，NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。或者读线程看到ready的值，却没有看到number的值，输出为0.这种现状称为“重排序”。

### 怎么用32位jvm对64位的数据进行原子操作？
使用volatile关键字修饰，或者加锁。

### Java并发计数
AtomicInteger。

### [CAS算法](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2compare-and-swap-cas)、[ABA问题](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#aba%E9%97%AE%E9%A2%98)

### [如果存储线程的阻塞队列满了，那么线程池的submit方法会阻塞在那里吗？](https://github.com/MinheZ/Notes/blob/master/note/Java%E5%B9%B6%E5%8F%91.md#%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5)

看具体饱和策略如何设置的。

### Threadlocal内存泄漏问题


## 创建线程有哪几种方式
- 继承 Thread 类
    - 定义一个类继承 Thread
    - 重写 run 方法
    - 创建子类对象，也就是创建线程对象
    - 调用 start 方法，之后虚拟机将调用该线程的 run 方法。
```java
public class Demo01 {
	public static void main(String[] args) {
		//创建自定义线程对象
		MyThread mt = new MyThread("新的线程！");
		//开启新线程
		mt.start();
		//在主方法中执行for循环
		for (int i = 0; i < 10; i++) {
			System.out.println("main线程！"+i);
		}
	}
}
public class MyThread extends Thread {
	//定义指定线程名称的构造方法
	public MyThread(String name) {
		//调用父类的String参数的构造方法，指定线程的名称
		super(name);
	}
	/**
	 * 重写run方法，完成该线程执行的逻辑
	 */
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(getName()+"：正在执行！"+i);
		}
	}
}
```
### 手动调用 run 方法能开启线程吗
不可以，手动调用仅是对象调用方法。线程对象调用start开启线程，并让jvm调用run方法在开启的线程中执行。

- 实现 Runnable 接口
